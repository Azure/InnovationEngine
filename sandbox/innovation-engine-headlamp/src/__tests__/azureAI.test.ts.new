// Unit tests for AzureAI service
import { describe, test, expect, beforeEach, vi } from 'vitest';
import { AzureAIService } from '../services/azureAI';

// Mock the Azure OpenAI client
vi.mock('openai', () => {
  const mockCreate = vi.fn();
  return {
    AzureOpenAI: vi.fn().mockImplementation(() => ({
      chat: {
        completions: {
          create: mockCreate
        }
      }
    }))
  };
});

// Import the mocked module to access the mock
import { AzureOpenAI } from 'openai';

describe('AzureAIService', () => {
  let service: AzureAIService;
  let mockCreate: any;
  
  beforeEach(() => {
    // Reset mocks before each test
    vi.resetAllMocks();
    
    // Create service instance with test config
    service = new AzureAIService({
      apiKey: 'test-api-key',
      endpoint: 'https://test-endpoint.openai.azure.com',
      deploymentId: 'test-deployment'
    });
    
    // Get the mock create function
    mockCreate = (service as any).client.chat.completions.create;
  });

  test('should create an instance with the provided configuration', () => {
    expect(service).toBeDefined();
    expect(AzureOpenAI).toHaveBeenCalledWith({
      apiKey: 'test-api-key',
      endpoint: 'https://test-endpoint.openai.azure.com',
      apiVersion: '2023-12-01-preview',
      dangerouslyAllowBrowser: true
    });
  });

  test('getCompletion should make a request to Azure OpenAI API', async () => {
    // Mock successful response
    const mockResponse = {
      choices: [{
        message: { content: 'Test response' }
      }]
    };
    
    mockCreate.mockResolvedValueOnce(mockResponse);
    
    // Test messages with explicitly typed role
    const messages = [
      { role: 'system' as const, content: 'You are a helpful assistant.' },
      { role: 'user' as const, content: 'Hello, can you help me?' }
    ];
    
    // Call the getCompletion method
    const result = await service.getCompletion(messages);
    
    // Verify the result
    expect(result).toBe('Test response');
    
    // Verify that the SDK create method was called with the right parameters
    expect(mockCreate).toHaveBeenCalledTimes(1);
    expect(mockCreate).toHaveBeenCalledWith({
      model: 'test-deployment',
      messages: [
        { role: 'system', content: 'You are a helpful assistant.' },
        { role: 'user', content: 'Hello, can you help me?' }
      ],
      max_tokens: 1000,
      temperature: 0.7,
      top_p: 0.95,
      frequency_penalty: 0,
      presence_penalty: 0,
      stop: undefined
    }, {
      maxRetries: 3
    });
  });

  test('getCompletion should handle API errors', async () => {
    // Mock API error from the SDK
    const error = new Error('Azure AI API client error (401): Unauthorized access') as any;
    error.status = 401;
    mockCreate.mockRejectedValueOnce(error);
    
    // Test messages with explicitly typed role
    const messages = [
      { role: 'user' as const, content: 'Hello, can you help me?' }
    ];
    
    // Expect the getCompletion method to throw an error
    await expect(service.getCompletion(messages)).rejects.toThrow('Azure AI API client error (401)');
  });

  test('getCompletion should handle network errors', async () => {
    // Mock network error from the SDK
    const error = new Error('Network error');
    mockCreate.mockRejectedValueOnce(error);
    
    // Test messages with explicitly typed role
    const messages = [
      { role: 'user' as const, content: 'Hello?' }
    ];
    
    // Expect the getCompletion method to throw an error
    await expect(service.getCompletion(messages)).rejects.toThrow('Network error');
  });

  test('should pass options correctly to the API call', async () => {
    // Mock successful response
    const mockResponse = {
      choices: [{
        message: { content: 'Custom options response' }
      }]
    };
    
    mockCreate.mockResolvedValueOnce(mockResponse);
    
    // Test messages and custom options with explicitly typed role
    const messages = [{ role: 'user' as const, content: 'Hello with options' }];
    const options = {
      maxTokens: 2000,
      temperature: 0.5,
      topP: 0.8,
      frequencyPenalty: 0.2,
      presencePenalty: 0.2,
      stop: ['###']
    };
    
    // Call the getCompletion method with custom options
    const result = await service.getCompletion(messages, options);
    
    // Verify the result
    expect(result).toBe('Custom options response');
    
    // Verify that the SDK create method was called with custom options
    expect(mockCreate).toHaveBeenCalledTimes(1);
    expect(mockCreate).toHaveBeenCalledWith({
      model: 'test-deployment',
      messages: messages,
      max_tokens: 2000,
      temperature: 0.5,
      top_p: 0.8,
      frequency_penalty: 0.2,
      presence_penalty: 0.2,
      stop: ['###']
    }, {
      maxRetries: 3
    });
  });

  test('should retry on rate limiting (429) responses', async () => {
    // Mock rate limit error that the SDK will handle automatically
    const rateLimitError = new Error('Azure AI API rate limit exceeded: Too many requests') as any;
    rateLimitError.status = 429;
    
    mockCreate
      .mockRejectedValueOnce(rateLimitError)
      .mockResolvedValueOnce({
        choices: [{
          message: { content: 'Response after retry' }
        }]
      });
    
    // Test messages
    const messages = [{ role: 'user' as const, content: 'Hello with rate limit' }];
    
    // Call the getCompletion method with custom retry settings
    const result = await service.getCompletion(messages, { maxRetries: 1 });
    
    // Verify the result
    expect(result).toBe('Response after retry');
    
    // Verify that the SDK create method was called twice (initial + retry)
    expect(mockCreate).toHaveBeenCalledTimes(2);
  });

  test('should respect configurable retry settings', async () => {
    // Mock server errors followed by success
    const serverError = new Error('Azure AI API server error (500): Internal server error') as any;
    serverError.status = 500;
    
    mockCreate
      .mockRejectedValueOnce(serverError)
      .mockRejectedValueOnce(serverError)
      .mockResolvedValueOnce({
        choices: [{
          message: { content: 'Response after multiple server errors' }
        }]
      });
    
    // Test messages and custom retry settings
    const messages = [{ role: 'user' as const, content: 'Test with custom retry settings' }];
    const options = {
      maxRetries: 5
    };
    
    // Call the getCompletion method with custom options
    const result = await service.getCompletion(messages, options);
    
    // Verify the result
    expect(result).toBe('Response after multiple server errors');
    
    // Verify that the SDK create method was called the expected number of times
    expect(mockCreate).toHaveBeenCalledTimes(3);
  });
  
  test('should fail after exceeding maximum rate limit retries', async () => {
    // Mock multiple rate limit errors that exceed the retry limit
    const rateLimitError = new Error('Azure AI API rate limit exceeded: Too many requests') as any;
    rateLimitError.status = 429;
    
    mockCreate
      .mockRejectedValueOnce(rateLimitError)
      .mockRejectedValueOnce(rateLimitError)
      .mockRejectedValueOnce(rateLimitError);
    
    // Test messages
    const messages = [{ role: 'user' as const, content: 'Hello with excessive rate limit' }];
    
    // Set a low maxRetries value to make the test fail faster
    const options = {
      maxRetries: 2
    };
    
    // Expect the getCompletion method to throw a rate limit error after exceeding retries
    await expect(service.getCompletion(messages, options)).rejects.toThrow('rate limit exceeded');
  });
  
  // This test is marked to skip in CI environments where rate limits may be a concern
  test.runIf(!process.env.CI)('should respect Retry-After header for rate limiting', async () => {
    // With the SDK, retry logic including Retry-After headers is handled automatically
    // We'll test that the SDK properly handles the maxRetries configuration
    const rateLimitError = new Error('Azure AI API rate limit exceeded: Too many requests') as any;
    rateLimitError.status = 429;
    
    mockCreate
      .mockRejectedValueOnce(rateLimitError)
      .mockResolvedValueOnce({
        choices: [{
          message: { content: 'Response after retry' }
        }]
      });
    
    // Test messages
    const messages = [{ role: 'user' as const, content: 'Test Retry-After header' }];
    
    // Call the getCompletion method
    const result = await service.getCompletion(messages, { maxRetries: 1 });
    
    // Verify the result
    expect(result).toBe('Response after retry');
    
    // Verify that the SDK properly retried
    expect(mockCreate).toHaveBeenCalledTimes(2);
  });
});
